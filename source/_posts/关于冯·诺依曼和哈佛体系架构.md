---
title: 关于冯·诺依曼和哈佛体系架构
date: 2024-08-10 18:55:20
tags:
  - Computer
categories:	
  - Computer
description: 关于冯·诺依曼和哈佛体系架构
---

# 关于冯·诺依曼和哈佛体系架构

​	冯·诺依曼架构（Von Neumann architecture）和哈佛架构（Harvard architecture）是两种不同的计算机系统架构，它们在处理器如何访问存储器方面有着本质的区别。下面详细介绍这两种架构及其区别：

### 1. 冯·诺依曼架构

- **概念**：冯·诺依曼架构由数学家约翰·冯·诺依曼在20世纪40年代提出。它是最早被广泛应用的计算机体系结构之一。
- **特点**：
  - **统一存储器**：程序指令和数据存储在同一个内存空间中。代码和数据共享同一个地址空间和存储器。
  - **单一总线系统**：处理器通过同一条总线（即冯·诺依曼总线）来访问程序指令和数据。这意味着在一个时间点上，处理器只能访问一个字节或一个指令，要么是从内存读取指令，要么是访问数据。
  - **顺序执行**：程序指令按顺序存储在内存中，处理器按顺序从内存中读取指令并执行。
- **优点**：
  - **设计简单**：因为程序和数据共享同一个存储器，架构相对简单。
  - **存储器利用率高**：只需要一个存储器模块，用于存储程序和数据。
- **缺点**：
  - **瓶颈问题**：因为程序和数据共享一条总线，所以在执行过程中，指令获取和数据访问可能会相互干扰，导致“冯·诺依曼瓶颈”。这种瓶颈限制了处理器的性能，因为每次只能做一件事，要么获取指令，要么读取/写入数据。

### 2. 哈佛架构

- **概念**：哈佛架构最早应用于哈佛大学的Mark I计算机中，之后在很多嵌入式系统和数字信号处理器（DSP）中得到了广泛应用。
- **特点**：
  - **分离存储器**：程序指令和数据分别存储在不同的存储器中。程序存储器（通常是只读的，如ROM或Flash）和数据存储器（通常是可读写的，如RAM）独立存在，并且有独立的地址空间。
  - **双总线系统**：处理器通过两条独立的总线分别访问程序指令和数据。这允许同时读取指令和访问数据，消除了指令和数据访问之间的冲突。
  - **并行处理**：由于指令和数据在不同的存储器中，并且有各自的总线，处理器可以在同一个时钟周期内同时读取指令和数据，极大提高了处理器的效率。
- **优点**：
  - **高性能**：因为指令和数据的访问是独立的，总线不会互相干扰，可以同时获取指令和处理数据，减少了访问延迟。
  - **优化存储器**：可以根据需要对指令存储器和数据存储器进行独立优化，提升系统整体性能。
- **缺点**：
  - **设计复杂**：由于程序和数据存储器分开，需要两套独立的存储器和总线，这增加了系统设计的复杂性和成本。
  - **灵活性较差**：存储器空间是固定分配的，如果指令存储器不够用而数据存储器有富余，或反之，则可能无法有效利用存储资源。

### 3. 区别总结

- **存储器组织**：冯·诺依曼架构使用统一存储器，程序和数据共享一个内存空间；哈佛架构使用分离存储器，程序和数据存储在不同的内存空间。
- **总线系统**：冯·诺依曼架构使用单一的总线系统来访问程序和数据；哈佛架构使用两条独立的总线来同时访问程序和数据。
- **性能**：哈佛架构通常在执行效率上优于冯·诺依曼架构，因为它消除了指令和数据访问的冲突。
- **应用场景**：
  - **冯·诺依曼架构**：常见于通用计算机系统，如个人电脑、服务器等，适用于需要大量存储和相对灵活的内存使用的场景。
  - **哈佛架构**：常见于嵌入式系统、DSP、实时控制系统中，适用于对性能和实时性要求较高的场景。

### 4. 混合架构

​	在现代计算机系统中，很多架构实际上结合了冯·诺依曼和哈佛架构的特点。例如，一些微控制器和处理器可能在内部使用哈佛架构（独立的指令缓存和数据缓存），但在外部总线设计上采用冯·诺依曼架构（统一的内存地址空间）。

### 5.为什么 x86 PC属于冯·诺依曼架构？

​	说个人x86 PC属于冯·诺依曼架构，是因为它的基本工作原理符合冯·诺依曼架构的特点，即**指令和数据共享同一个内存空间**，并通过统一的总线系统来访问这些存储器。在这类架构中，程序指令和数据都存储在内存（RAM）中，CPU通过同一个总线系统读取指令和数据。

#### 1. **冯·诺依曼架构的特点**

- **统一存储器**：在冯·诺依曼架构中，程序指令和数据共享一个存储器（通常是RAM），并共享同一个地址空间。这意味着程序代码和数据可以存储在同一个内存中，CPU可以通过同样的方式来访问它们。
- **单一总线系统**：CPU通过同一个总线系统访问存储器，无论是读取指令还是数据。

#### 2. **x86架构的实现方式**

- **内存（RAM）中的指令和数据**：在典型的x86 PC系统中，当程序运行时，程序的指令和需要操作的数据都会被加载到RAM中。CPU从RAM中读取指令，然后根据指令操作数据，也是在RAM中进行。
- **硬盘的作用**：硬盘（或SSD）是系统的长期存储器，用于存放程序和数据的持久化文件。硬盘并不直接参与指令的执行。只有当程序被加载到内存后，CPU才能执行其中的指令。因此，硬盘中的程序文件（如可执行文件）在程序运行时，会被加载到内存中。可以认为硬盘是存储数据和程序的源头，但执行必须在内存中进行。

#### 3. **具体工作流程**

1. **程序加载**：
   - 当你在PC上运行一个程序时，操作系统会将程序的可执行文件（存储在硬盘上）加载到RAM中。这包括程序的指令和初始数据。
2. **指令执行**：
   - CPU的程序计数器（PC）指向内存中存储的第一条指令，CPU从内存读取该指令，并将其解码和执行。
   - 在执行过程中，如果需要操作数据，CPU也会从内存中读取相关的数据（或将数据写入内存）。
3. **数据存储**：
   - 操作过程中，如果需要将数据持久化保存，程序会通过操作系统将数据写回硬盘（比如保存文件）。但在程序运行期间，数据一般存储在内存中，供CPU快速访问。

#### 4. **为什么x86 PC属于冯·诺依曼架构**

- **统一的内存模型**：程序指令和数据都被加载到内存中，并且共享一个统一的地址空间。CPU可以通过同样的地址访问机制来操作指令和数据。
- **单一总线系统**：CPU通过同一个总线（例如系统总线）来访问内存中的指令和数据，没有专门的独立总线分别处理指令和数据的读取。

#### 5. **常见误解：指令在内存，数据在硬盘**

- **内存与硬盘的角色**：有时会有一种误解，即指令在内存中执行，而数据在硬盘中。这实际上是对存储层次的混淆。虽然硬盘确实存储了数据和程序文件，但在程序运行时，必须将数据和指令都加载到内存中，供CPU访问和操作。

#### 总结

x86 PC 属于冯·诺依曼架构，因为程序指令和数据共享同一个内存空间，并通过统一的总线系统访问。虽然硬盘用于存储程序和数据文件，但实际执行的过程发生在内存中，CPU直接从内存读取指令并操作数据。因此，硬盘是用于持久化存储的设备，而内存是用于执行期间快速访问的数据和指令的存储器。

### 6.51单片机和STM32F103分别属于什么架构？

51单片机和STM32F103分别属于不同的计算机架构：

#### 1. **51单片机的架构**

51单片机（如Intel 8051系列）采用的是**哈佛架构**。

- 哈佛架构的特点：
  - **分离存储器**：程序存储器和数据存储器是分离的，程序存储在ROM（或Flash）中，数据存储在RAM中。它们各自有独立的地址空间。
  - **独立的总线**：CPU使用不同的总线访问程序存储器和数据存储器。由于指令和数据是分开处理的，CPU可以同时获取指令和操作数据，这提高了处理效率。
  - **优点**：由于程序和数据存储器分离，指令获取和数据访问可以并行进行，减少了访问冲突，提升了效率。

#### 2. **STM32F103的架构**

STM32F103基于ARM Cortex-M3内核，采用的是**改进的哈佛架构**。

- 改进的哈佛架构的特点：
  - **程序和数据存储器分离**：与传统哈佛架构相似，指令存储器和数据存储器是分离的，内部有独立的指令总线和数据总线。
  - **统一的外部地址空间**：尽管内部采用哈佛架构，外部表现为一个统一的地址空间。这意味着程序存储器和数据存储器可以被映射到同一个地址空间，方便编程和访问。
  - **指令和数据缓存**：Cortex-M3内核可能使用了指令缓存和数据缓存，以提高访问速度。缓存的使用进一步优化了指令和数据的处理效率。

#### 总结

- **51单片机**：属于**传统的哈佛架构**，程序存储器和数据存储器是完全分离的，分别使用不同的地址空间和总线。
- **STM32F103**：采用的是**改进的哈佛架构**。虽然内部仍然分离指令和数据存储器，但它对外呈现出统一的地址空间，方便了编程，并且结合了冯·诺依曼架构的优势，进一步提升了系统的效率和灵活性。

### 7.STM32 微控制器与 x86 架构的PC在运行程序的方式上的区别

STM32 微控制器与 x86 架构的个人电脑在运行程序的方式上有一些显著的区别。简单来说，STM32 通常不会像 x86 个人电脑那样将程序从非易失性存储器（如闪存）复制到 RAM 中再执行，而是直接从闪存中运行程序代码。

#### 1. **x86 个人电脑的运行方式**

- 在 x86 个人电脑中，程序通常存储在非易失性存储器（如硬盘、SSD）中。当你运行一个程序时，操作系统会将程序的代码和数据从硬盘加载到主存（RAM）中，CPU 然后从 RAM 中读取指令并执行。
- 这样做的原因是，RAM 的读写速度远快于硬盘或 SSD，可以显著提高程序的执行速度。

#### 2. **STM32 微控制器的运行方式**

- 在 STM32 微控制器中，程序代码通常存储在片内的闪存中。与 x86 架构不同，STM32 的 CPU 通常直接从闪存中读取指令并执行。
- STM32 的闪存设计允许直接执行代码（称为 **Execute in Place，XIP**），这意味着不需要像 x86 系统那样将代码复制到 RAM 中再执行。CPU 可以直接从闪存中提取指令，这样既简化了启动过程，也节省了宝贵的 RAM 空间。

#### 3. **RAM 的作用**

- 尽管程序代码通常从闪存直接执行，RAM 在 STM32 系统中仍然起着关键作用。RAM 主要用于存储：
  - **数据段**: 包括全局变量、静态变量等，这些数据在程序运行过程中可能会被频繁读写。
  - **堆栈**: 用于存储函数调用时的局部变量、返回地址等信息。
  - **动态分配的内存**: 通过 malloc 等函数动态分配的内存空间。

#### 4. **特殊情况**

- 在某些情况下，如果闪存访问速度不能满足要求（如高速操作要求），开发者可以手动将部分关键代码段复制到 RAM 中运行，以提高执行效率。这种情况在实时性要求高的应用中可能会出现，但在大多数情况下，STM32 直接从闪存执行代码是足够的。

#### 总结

STM32 微控制器不会像 x86 个人电脑那样在运行程序前将程序代码复制到 RAM 中。相反，STM32 通常直接从片内闪存中执行代码，这简化了系统设计并节省了 RAM 资源。RAM 主要用于存储数据、堆栈和动态分配的内存，而不是代码。
